1.Https比Http更安全，但是性能更低

2.常见的请求头
请求头
host                          域名
Connection                    长链接
Upgrade-Insecure-Requests     升级为Https
* User-Agent                  用户代理，提供系统信息
* Referer                     页面跳转处，防盗用
* Cookie                      状态保持

响应头
 Set-cookie

3.状态响应码：
1××：消息响应
2××：成功响应
3××：重定响应
4××：客户端错误
5××：服务器端错误

·500 内部服务器错误

Internal Server Error 500内部服务器错误，服务器遇到未知无法解决的问题。

一般情况下，出现500响应状态的原因有很多种，但是主要的是“程序代码和服务器配置”两个问题。
相对于代码而言，就是对站点进行升级，网页改版，新增加了一些常用的插件。就比如WordPress插件的版本可能就需要更高版本的PHP才能兼容。
而相对服务器而言的话，更多的是在系统版本升级导致，就比如最开始使用的是Windows Server 2003，后期想要升级2008、2012等版本的时候配置稍有不慎就会导致Internal Server Error 500。

·404 请求错误

Not Found 404 错误请求，​因发送的请求语法错误,服务器无法正常读取。

相信绝大多数的人都见过404的状态码，当用户试图请求Web服务器上一个不存在的资源时，就会触发Not Found404。
出现404状态码可能是链接失效导致，也有可能是URL拼写错误，还有可能是因为Web服务器将所请求的资源移到了其他的地方。一般的网站都会设置自定义页面以防链接失效所产生不良的影响。

·403 禁止访问

Forbidden 403 禁止访问，客户端没有权利访问所请求内容,服务器拒绝本次请求。

状态码403通常代表客户端错误，是指的服务器端有能力处理该请求，但是拒绝授权访问。
这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。

·400 错误请求

Bad Request 400 错误请求，因发送的请求语法错误,服务器无法正常读取。

状态码400表示该语法无效，服务器无法理解该请求。客服端不应该在未经修改的情况下重复此请求。一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。

·401 未经授权
Unauthorized 401 未经授权，需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。

状态码401就是Web服务器认为，客户端发送的HTTP数据流浪是正确的，但是进入URL资源的时候需要身份验证，而客户端尚未提供相关的验证信息，或者是已提供但是没有通过验证。这也是通常所知的“HTTP基本验证”。

·200 请求成功

200 OK 请求成功，表示已经请求成功，默认情况下的状态码为200的响应就可以被缓存了。

不同请求方式对于请求成功的意义如下：

GET: 已经取得资源，并将资源添加到响应的消息体中。
HEAD: 响应的消息体为头部信息。
POST: 响应的消息体中包含此次请求的结果。
TRACE: 响应的消息体中包含服务器接收到的请求信息。
PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。

·206 部分内容

Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码​。

状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。

·301 永久重定向

Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。

尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。

·302 临时重定向

Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。

即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。
所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。


·502 无效网关

Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。

bad gateway502代表您所访问的网站出了问题，
因为502 Bad Gateway 服务器作为网关或者代理时，是为了完成访问下一个服务器，但该服务器返回了非法的应答。也许是暂时的，也许是的。建议大家稍等一下再从新访问试试。



·503：有可能因为爬虫频繁访问url，使服务器忽视爬虫请求，最终返回503.


＜以抓包得到的源码作为判断依据，
Element中的源码是渲染之后的源码，不能作为判断标准。＞



4.浏览器请求的过程
·浏览器：
	发送所有请求，进行渲染
·爬虫：
	只发送指定请求，不会渲染

爬虫寻找数据的三大要素：
·骨骼文件：
	html静态文件
·肌肉文件：
	js/ajax请求
·皮肤：
	css（层叠样式表）/font（字体）/img（图片）等

抓包过程：
根据发送请求的流程分别在骨骼/肌肉/皮肤响应中查找数据

POST / HTTP1.1 Host:www.wrox.com User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022) Content-Type:application/x-www-form-urlencoded Content-Length:40 Connection: Keep-Alive
name=Professional%20Ajax&publisher=Wiley 说明:请求行开始处的GET改为POST,以表示不同的请求类型.       Content-Type说明了请求主体的内容是如何编码的.浏览器始终以application/x-www-form-urlencoded的格式编码来传送数据,这是针对简单URL编码的MIME类型.Content-Length说明了请求主体的字节数.       最后请求主体.名称-值对的形式.



Ruquests模块
	- urllib模块（古老）
	- requests模块（新，高效简洁）

Requests模块：python中原生的基于网络请求的模块。
	作用：模拟浏览器发请求。
如何使用：
指定url
发起请求
获取响应数据
持久化存储（响应数据）

环境安装：
  pip install requests


写爬虫时需要注意的点：
 ·header里面的格式一定要注意不能错。
